package skuber.operator.crd

import play.api.libs.json.*
import scala.deriving.Mirror
import java.time.{Instant, ZonedDateTime, ZoneOffset}
import java.time.format.DateTimeFormatter

/**
 * Helper for creating Format instances for container types (List, Option, etc.)
 * when the element format is provided explicitly. This avoids implicit search
 * issues when the element type's format is generated by the same macro.
 */
object ContainerFormats:

  def listFormat[T](elementFormat: Format[T]): Format[List[T]] =
    Format(
      Reads.list(using elementFormat),
      Writes.list(using elementFormat)
    )

  def optionFormat[T](elementFormat: Format[T]): Format[Option[T]] =
    Format(
      Reads { json =>
        json.validateOpt(using elementFormat).map {
          case Some(null) => None
          case other => other
        }
      },
      Writes.optionWithNull(using elementFormat)
    )

  def setFormat[T](elementFormat: Format[T]): Format[Set[T]] =
    Format(
      Reads.set(using elementFormat),
      Writes.set(using elementFormat)
    )

  def seqFormat[T](elementFormat: Format[T]): Format[Seq[T]] =
    Format(
      Reads.seq(using elementFormat),
      Writes.seq(using elementFormat)
    )

  def mapFormat[V](valueFormat: Format[V]): Format[Map[String, V]] =
    Format(
      Reads.map(using valueFormat),
      Writes.map(using valueFormat)
    )

  def vectorFormat[T](elementFormat: Format[T]): Format[Vector[T]] =
    Format(
      Reads.seq(using elementFormat).map(_.toVector),
      Writes.seq(using elementFormat).contramap(_.toSeq)
    )

/**
 * Helper for creating Format instances for Scala 3 enums using their declared values.
 * Works for common singleton cases (simple values) where the desired JSON mapping is to/from the string value
 * of each case
 * e.g.' enum Color: case Red, Blue, Green' will get its values mapped to JSON string values "Red", "Blue", "Green"
 */
object EnumFormats:

  def enumFormat[E](values: Array[E]): Format[E] =
    Format(
      Reads.StringReads.flatMap { name =>
        values.find(_.toString == name) match
          case Some(value) => Reads.pure(value)
          case None => Reads(_ => JsError(s"Invalid enum value: $name"))
      },
      Writes.StringWrites.contramap(_.toString)
    )

/**
 * Formats for common Kubernetes-compatible types.
 * These are automatically used by the @customResource macro when generating formats.
 */
object CommonFormats:

  /**
   * Format for ZonedDateTime using ISO 8601 format (Kubernetes-compatible).
   * Serializes to UTC with 'Z' suffix, e.g., "2026-02-10T15:30:00Z"
   */
  given zonedDateTimeFormat: Format[ZonedDateTime] = Format(
    Reads { json =>
      json.validate[String].flatMap { str =>
        try
          // Parse ISO 8601 format, handling both 'Z' suffix and offset formats
          val parsed = if str.endsWith("Z") then
            ZonedDateTime.parse(str, DateTimeFormatter.ISO_INSTANT.withZone(ZoneOffset.UTC))
          else
            ZonedDateTime.parse(str, DateTimeFormatter.ISO_DATE_TIME)
          JsSuccess(parsed)
        catch
          case e: Exception => JsError(s"Invalid date-time format: ${e.getMessage}")
      }
    },
    Writes { dt =>
      // Convert to UTC and format as ISO 8601 (Kubernetes expects this format)
      JsString(dt.toInstant.atZone(ZoneOffset.UTC).format(DateTimeFormatter.ISO_INSTANT))
    }
  )

  /**
   * Format for Instant using ISO 8601 format (Kubernetes-compatible).
   * Serializes with 'Z' suffix, e.g., "2026-02-10T15:30:00Z"
   */
  given instantFormat: Format[Instant] = Format(
    Reads { json =>
      json.validate[String].flatMap { str =>
        try
          JsSuccess(Instant.parse(str))
        catch
          case e: Exception => JsError(s"Invalid instant format: ${e.getMessage}")
      }
    },
    Writes { instant =>
      JsString(instant.toString)
    }
  )

/**
 * Helper for creating OFormat instances for case classes with explicit field formats.
 * Used by @customResource macro to support nested case classes and container types.
 */
object CrdFormatHelper:

  /**
   * Create an OFormat for a case class, passing field formats and default values explicitly.
   * This avoids compile-time implicit lookup which fails for macro-generated formats.
   *
   * When a field is missing from JSON:
   * - If the field has a default value, use it
   * - Otherwise, try to parse JsNull (works for Option types, fails for others)
   *
   * @param fieldNames Names of the case class fields
   * @param fieldFormats Format instances for each field, in field order
   * @param defaults Optional default values for each field (None if no default)
   * @param mirror Mirror for the case class type
   */
  def createFormat[T](
    fieldNames: List[String],
    fieldFormats: List[Format[?]],
    defaults: List[Option[Any]],
    mirror: Mirror.ProductOf[T]
  ): OFormat[T] = OFormat(
    Reads[T] { json =>
      try
        val values = fieldNames.zip(fieldFormats).zip(defaults).map { case ((name, format), default) =>
          (json \ name) match
            case JsDefined(v) =>
              // Field present - parse it
              v.as(using format.asInstanceOf[Reads[Any]])
            case _: JsUndefined =>
              // Field missing - use default if available, otherwise try JsNull
              default match
                case Some(defaultVal) => defaultVal
                case None => JsNull.as(using format.asInstanceOf[Reads[Any]])
        }
        val product = mirror.fromProduct(Tuple.fromArray(values.toArray))
        JsSuccess(product)
      catch
        case e: JsResultException => JsError(e.errors)
        case e: Exception => JsError(e.getMessage)
    },
    OWrites[T] { o =>
      val values = o.asInstanceOf[Product].productIterator.toList
      val pairs = fieldNames.zip(fieldFormats).zip(values).map { case ((name, format), value) =>
        name -> format.asInstanceOf[Writes[Any]].writes(value)
      }
      JsObject(pairs)
    }
  )

  /**
   * Backwards-compatible version without defaults (all fields required in JSON).
   */
  def createFormat[T](
    fieldNames: List[String],
    fieldFormats: List[Format[?]],
    mirror: Mirror.ProductOf[T]
  ): OFormat[T] =
    createFormat(fieldNames, fieldFormats, fieldNames.map(_ => None: Option[Any]), mirror)
